### Linux正则表达式

​	由一类特殊字符及文本字符所编写的模式，其中有些字符不表示其字面意义，而是用于表示控制或通配的功能；

分2类：

1. 基本正则表达式：BRE
2. 扩展正则表达式：ERE



### 正则表达式的意义

- 处理大量的字符串
- 处理文本

通过特殊符号的辅助，可以让Linux管理员快速过滤、替换、处理所需的字符串、文本、让工作高效。

通常Linux运维工作，都是面临带有大量的字符串的内容，如：

- 配置文件
- 程序代码
- 命令输出结果
- 日志文件

且此类字符串内容，有特定的需要，**查找出符合工作需要的特定的字符串**。因此正则表达式就出现了

- 正则表达式是一套规则和方法
- 正则工作时以单位进行，**一次处理一行**
- 正则表达式化繁为简，提高工作效率
- Linux仅受三剑客（**sed、awk、grep**）支持，其他命令无法使用

正则表达式应用非常广泛，应用如python、Java、Perl等，**Linux下普通命令无法使用正则表达式，只能使用三剑客**

**通配符是大部分命令都支持的，用于查找文件或目录，而正则表达式是通过三剑客命令在文件（数据流）中过滤内容 的**



### Linux三剑客

文本处理工具，均支持正则表达式引擎

- grep:文本过滤工具，（模式：pattern）工具
- sed:stream editor, 流编辑器，文本编辑工具
- awk：linux的文本报告生成器（格式化文本），Linux上是gawk



### 正则表达式的分类

Linux三剑客主要分为2类

- 基本正则表达式（BRE）

BRE对应元字符有 ^$.[]*

- 扩展正则表达式（ERE）

```
ERE在BRE基础上增加上 () {} ? + | 等字符
```



#### 基本正则表达式BRE集合

- 匹配字符
- 匹配次数
- 位置锚定

| 符号   | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| ^      | 尖角号，用于模式的最左侧，如"^oldboy", 匹配以oldboy单词开头的行 |
| $      | 美元符，用于模式的最右侧，如“$oldboy”, 表示以oldboy单词结尾的行 |
| ^$     | 组合符，表示空行                                             |
| .      | 匹配任意一个且只有一个字符，不能匹配空行                     |
| \      | 转义字符，让特殊含义字符，现出原形，还原本意，例如 \\.  表示小数点 |
| *      | 匹配前一个字符（连续出现）0次或1次以上，重复0次表示空，即匹配所有内容 |
| .*     | 组合符，匹配所有内容                                         |
| ^.*    | 组合符，匹配任意多个字符开头的内容                           |
| .*$    | 组合符，匹配以任意多个字符结尾的内容                         |
| [abc]  | 匹配[]集合内任意一个字符，a或b或c, 可以写[a-c]               |
| [^abc] | 匹配除了^后面的任意字符，^表示对[abc]取反                    |



#### 扩展正则表达式ERE集合

扩展正则必须使用 grep -E 才能生效

| 字符   | 作用                                        |
| ------ | ------------------------------------------- |
| +      | 匹配前一个字符1次或多次                     |
| [:/]+  | 匹配括号内的“ : ” 或者 " / " 字符一次或多次 |
| ?      | 匹配前一个字符0次或1次                      |
| \      | 表示或者，同时过滤多个字符串                |
| 0      | 分组过滤，被括起来的内容表示一个整体        |
| a{n,m} | 匹配前一个字符最少n次，最多m次              |
| a{n,}  | 匹配前一个字符最少n次                       |
| a{n}   | 匹配前一个字符正好n次                       |
| a{,m}  | 匹配一个字符最多m次                         |
|        |                                             |
|        |                                             |

Tips:

​	

```
1 grep命令需要使用参数 -E 即可支持正则表达式
2 egrep不推荐使用，使用grep -E 替代
3 grep 不加参数，得在特殊符号前面加"\"反斜杠，识别为正则
```



##### grep

作用：**文本搜索工具**，根据用户指定的“模式（过滤条件）”对目标文件逐行进行匹配检查，打印匹配到的行

模式：由正则表达式的“元符号” 及 “ 文本字符” 所编写出的<u>过滤条件</u>

```
1 语法
2 grep [options] [pattern] file
3 命令 参数 匹配模式  文件数据
4 				-i:忽略大小写
```



grep命令是Linux系统中最重要的命令之一，功能是从“文本文件” 或“管道数据流” 中筛选匹配的 “行 ” 和“数据”； 

如果再配合 正则表达式 ，功能十分强大，是Linux运维人员必备的命令

grep命令里的  匹配模式  就是你想要找的东西，可以是  普通的文字符号，  也可以是正则表达式

| 参数选项     | 解释说明               |
| ------------ | ---------------------- |
| -v           | 排除匹配结果           |
| -n           | 显示匹配的行与行号     |
| -i           | 不区分大小写           |
| -c           | 只统计匹配的行数       |
| -E           | 使用egrep命令          |
| --color=auto | 为grep过滤结果添加颜色 |
| -w           | 只匹配过滤的单词       |
| -o           | 只输出匹配的内容       |





```
demo:
	过滤掉#号开头的，去掉空行
	grep "^#" luffy.txt -v | grep "^$" -v   
	找出所有m开头的行
	grep -i -n "^m" luffy.txt
	找出'.' 结尾的行
	grep -n "\.$" luffy.txt
	找出所有允许登录的用户，解释器是/bin/bash的行
	grep -n "/bin/bash$" pwd.txt
	找出除了空行以外的信息
	grep -n "^$" luffy.txt -v
	


.*组合
	.表示任意一个字符，*表示匹配前一个字符0次或多次，放在一起表示，匹配所有内容，以及空格
	grep '.*' luffy.txt
	匹配e结尾，不管前面出现什么字符串
	grep ".*a" luffy.txt
	
[abc]中括号
	匹配所有的小写的字母
	grep "[a-z]" luffy.txt
	
	匹配所有的字符，包括大小写
	grep "[a-zA-Z]" luffy.txt
	
```




- ```
  扩展正则表达式
  demo：
  	
  +号
  表示匹配前一个字符1次或多次，必须使用grep -E
  	匹配所有的带有l的字符
  	grep -E "l+" luffy.txt
  
  ？号
  匹配前一个字符0次或1次
  	找出文件中包含gd或god的行
  	grep -E "go?d" luffy.txt
  	god #字母o出现1次
  	gd  #字母o出现0次
  	
  |符
  竖线|在正则中是 或者 的意思
  	找出系统中的txt文件，且名字里包含a或b的字符
  	find / -maxdepth 3 -name "*.txt" | grep -i -E "a|b"
  	
  ()小括号
  将一个或多个字符捆绑在一起，当作一个整体进行处理
  	小括号功能之一  分组过滤被括起来的内容，  括号内的内容表示一个整体
  	括号内的内容可以  被后面的"\n"正则引用， n为数字， 表示  引用第几个括号  的内容
  		\1:表示从左侧起，第一个括号中的模式所匹配到的字符
  		\2:从左侧起，第二个括号内中的模式匹配到的字符
  	找出包含good和glad的行
  	grep -E 'g(oo|la)d' luffy.txt
  	 
  
  
  ```

{n,m}匹配次数

重复前一个字符各种次数，可以通过 -o 参数显示明确的匹配过程

```
#匹配a字符，最少1次，最多3次
grep -E -o "a{1,3}" luffy.txt   #测试效果
```



